{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview A wrapper around argparser to help build CLIs from functions. Uses type-hints extensively . Setup Installation Install it directly into an activated virtual environment: 1 $ pip install arger or add it to your Poetry project: 1 $ poetry add arger Usage create a python file called test.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from arger import Arger def main ( param1 : int , param2 : str , kw1 = None , kw2 = False ): \"\"\"Example function with types documented in the docstring. :param param1: The first parameter. :param param2: The second parameter. :param kw1: this is optional parameter. :param kw2: this is boolean. setting flag sets True. \"\"\" print ( locals ()) arger = Arger ( main , prog = \"pytest\" , # for testing purpose. otherwise not required ) if __name__ == \"__main__\" : arger . run () Here Arger is just a subclass of ArgumentParser . It will not conceal you from using other argparse libraries. run this normally with 1 2 3 4 5 6 7 8 9 10 11 12 13 $ python test.py -h usage: pytest [ -h ] [ -k KW1 ] [ -w ] param1 param2 Example function with types documented in the docstring. positional arguments: param1 The first parameter. param2 The second parameter. optional arguments: -h, --help show this help message and exit -k KW1, --kw1 KW1 this is optional parameter. ( default: None ) -w, --kw2 this is boolean. setting flag sets True. ( default: False ) 1 2 $ python test.py 100 param2 { 'param1' : 100 , 'param2' : 'param2' , 'kw1' : None, 'kw2' : False } Checkout examples folder and documentation to see more of arger in action. It supports any level of sub-commands. Features Uses docstring to parse help comment for arguments. Supports google numpy rst Flags will be generated from parameter-name. e.g. def main(param: ...) -> -p, --param If needed you could declare it inside docstring like :param arg1: -a --arg this is the document . one can use Argument class to pass any values to the parser.add_argument function The decorated functions can be composed to form nested sub-commands of any level. Most of the Standard types supported . Please see examples for more supported types with examples. NOTE - *args supported but no **kwargs support yet. - all optional arguments that start with underscore is not passed to Parser . They are considered private to the function implementation. Some parameter names with special meaning - _namespace_ -> to get the output from the ArgumentParser.parse_args() - _arger_ -> to get the parser instance Argparser enhancements web-ui : https://github.com/nirizr/argparseweb extra actions : https://github.com/kadimisetty/action-hero automatic shell completions using argcomplete","title":"Overview"},{"location":"#overview","text":"A wrapper around argparser to help build CLIs from functions. Uses type-hints extensively .","title":"Overview"},{"location":"#setup","text":"","title":"Setup"},{"location":"#installation","text":"Install it directly into an activated virtual environment: 1 $ pip install arger or add it to your Poetry project: 1 $ poetry add arger","title":"Installation"},{"location":"#usage","text":"create a python file called test.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from arger import Arger def main ( param1 : int , param2 : str , kw1 = None , kw2 = False ): \"\"\"Example function with types documented in the docstring. :param param1: The first parameter. :param param2: The second parameter. :param kw1: this is optional parameter. :param kw2: this is boolean. setting flag sets True. \"\"\" print ( locals ()) arger = Arger ( main , prog = \"pytest\" , # for testing purpose. otherwise not required ) if __name__ == \"__main__\" : arger . run () Here Arger is just a subclass of ArgumentParser . It will not conceal you from using other argparse libraries. run this normally with 1 2 3 4 5 6 7 8 9 10 11 12 13 $ python test.py -h usage: pytest [ -h ] [ -k KW1 ] [ -w ] param1 param2 Example function with types documented in the docstring. positional arguments: param1 The first parameter. param2 The second parameter. optional arguments: -h, --help show this help message and exit -k KW1, --kw1 KW1 this is optional parameter. ( default: None ) -w, --kw2 this is boolean. setting flag sets True. ( default: False ) 1 2 $ python test.py 100 param2 { 'param1' : 100 , 'param2' : 'param2' , 'kw1' : None, 'kw2' : False } Checkout examples folder and documentation to see more of arger in action. It supports any level of sub-commands.","title":"Usage"},{"location":"#features","text":"Uses docstring to parse help comment for arguments. Supports google numpy rst Flags will be generated from parameter-name. e.g. def main(param: ...) -> -p, --param If needed you could declare it inside docstring like :param arg1: -a --arg this is the document . one can use Argument class to pass any values to the parser.add_argument function The decorated functions can be composed to form nested sub-commands of any level. Most of the Standard types supported . Please see examples for more supported types with examples. NOTE - *args supported but no **kwargs support yet. - all optional arguments that start with underscore is not passed to Parser . They are considered private to the function implementation. Some parameter names with special meaning - _namespace_ -> to get the output from the ArgumentParser.parse_args() - _arger_ -> to get the parser instance","title":"Features"},{"location":"#argparser-enhancements","text":"web-ui : https://github.com/nirizr/argparseweb extra actions : https://github.com/kadimisetty/action-hero automatic shell completions using argcomplete","title":"Argparser enhancements"},{"location":"1-arger/","text":"Arger Function Function's signature is used to create generate parser arguments. 1. Positional Arguments: Positional parameters become mandatory. 2. Optional Arguments: All keyword arguments (ones with default value) in the function become flags/optionals. 3. type annotations: used to determine the type and action of the arguments. The function will be dispatched with values converted to the respective types. Note : Use arger.Argument class as annotation in case you want to pass values to parser.add_argument . For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import arger from typing import * from enum import Enum # Type -> resulting `arger.add_argument` method call def _ ( a_st : str , # -> add_argument(dest='a', type=str) a_in : int , # -> add_argument(dest='a', type=int) a_tp : Tuple [ int , ... ], # -> add_argument(dest='a', type=int, nargs='+') : one or more a_tp_int : Tuple [ int , int ], # -> add_argument(dest='a', type=int, nargs='2') : consumes 2 positional a_ls : List [ int ], # -> add_argument(dest=\"a\", type=int, nargs=\"*\") : zero or more a_opt : Optional [ int ], # -> add_argument(dest=\"a\", type=int, nargs=\"?\") : zero or one positional a_en : Enum ( 'AnySubClsOfEnum' , 'ONE TWO' ), # -> add_argument(dest=\"a\", choices=list(cls), type=lambda x: cls[x]) : accepts str from cli and returns as an Enum. a_lt : Literal [ 'one' , 'two' ], # -> add_argment(dest=\"a_lt\", choices=[\"one\", \"two\"], type=str) : accepts str from cli and returns the same a_lt_in : Literal [ 1 , 2 ], # -> add_argment(dest=\"a_lt\", choices=[1, 2], type=int) : accepts str from cli and returns int a_cs2 : Annotated [ int , # -> Argument's type argument. also satisfies type checkers arger . Argument ( metavar = \"INT\" , action = ActionSubCls )], # -> add_argument(dest=\"a\", metavar=\"INT\", type=int, action=ActionSubCls) : all the arguments to the `Argument` will get delegated to add_argument kwarg : int = 0 , # -> add_argument(\"--kwarg\", \"-k\", dest=\"kwarg\", type=int, default=0) ): ... 4. Docstring (ReST or GoogleDoc) The top part of the docstring becomes the usage message for the command. Parameter docstrings become help message for the arguments/options of the command. Rest of the docstrings passed as epilog to the parser. ReST/GoogleDoc-style/NumpyDoc-style are supported Options-strings can further be defined in the docstring. 1 2 3 4 5 Args : name : [ short option and / or long option ] help text variable_name : - v -- verbose the help_text for the variable variable_name : - v the help_text no long option variable_name : -- verbose the help_text no short option","title":"Arger"},{"location":"1-arger/#arger","text":"","title":"Arger"},{"location":"1-arger/#function","text":"Function's signature is used to create generate parser arguments.","title":"Function"},{"location":"1-arger/#1-positional-arguments","text":"Positional parameters become mandatory.","title":"1. Positional Arguments:"},{"location":"1-arger/#2-optional-arguments","text":"All keyword arguments (ones with default value) in the function become flags/optionals.","title":"2. Optional Arguments:"},{"location":"1-arger/#3-type-annotations","text":"used to determine the type and action of the arguments. The function will be dispatched with values converted to the respective types. Note : Use arger.Argument class as annotation in case you want to pass values to parser.add_argument . For example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import arger from typing import * from enum import Enum # Type -> resulting `arger.add_argument` method call def _ ( a_st : str , # -> add_argument(dest='a', type=str) a_in : int , # -> add_argument(dest='a', type=int) a_tp : Tuple [ int , ... ], # -> add_argument(dest='a', type=int, nargs='+') : one or more a_tp_int : Tuple [ int , int ], # -> add_argument(dest='a', type=int, nargs='2') : consumes 2 positional a_ls : List [ int ], # -> add_argument(dest=\"a\", type=int, nargs=\"*\") : zero or more a_opt : Optional [ int ], # -> add_argument(dest=\"a\", type=int, nargs=\"?\") : zero or one positional a_en : Enum ( 'AnySubClsOfEnum' , 'ONE TWO' ), # -> add_argument(dest=\"a\", choices=list(cls), type=lambda x: cls[x]) : accepts str from cli and returns as an Enum. a_lt : Literal [ 'one' , 'two' ], # -> add_argment(dest=\"a_lt\", choices=[\"one\", \"two\"], type=str) : accepts str from cli and returns the same a_lt_in : Literal [ 1 , 2 ], # -> add_argment(dest=\"a_lt\", choices=[1, 2], type=int) : accepts str from cli and returns int a_cs2 : Annotated [ int , # -> Argument's type argument. also satisfies type checkers arger . Argument ( metavar = \"INT\" , action = ActionSubCls )], # -> add_argument(dest=\"a\", metavar=\"INT\", type=int, action=ActionSubCls) : all the arguments to the `Argument` will get delegated to add_argument kwarg : int = 0 , # -> add_argument(\"--kwarg\", \"-k\", dest=\"kwarg\", type=int, default=0) ): ...","title":"3. type annotations:"},{"location":"1-arger/#4-docstring-rest-or-googledoc","text":"The top part of the docstring becomes the usage message for the command. Parameter docstrings become help message for the arguments/options of the command. Rest of the docstrings passed as epilog to the parser. ReST/GoogleDoc-style/NumpyDoc-style are supported Options-strings can further be defined in the docstring. 1 2 3 4 5 Args : name : [ short option and / or long option ] help text variable_name : - v -- verbose the help_text for the variable variable_name : - v the help_text no long option variable_name : -- verbose the help_text no short option","title":"4. Docstring (ReST or GoogleDoc)"},{"location":"2-alternatives/","text":"Similar Projects argh has similar goals as to ease up using argparser. doesn't support type hints. No recent releases. typer if you are using click , I highly recommend you to check this library. it is neat and many features are drawn from it. doesn't support loading help text for arguments from docstrings. invoke doesn't support type hints. cliche has similar goals. doesn't cover much use cases as arger . cliar no docstring support for help argument. Recommended Alternatives Projects that I highly recommend you to checkout. clize nuclear defopt","title":"Similar Projects"},{"location":"2-alternatives/#similar-projects","text":"","title":"Similar Projects"},{"location":"2-alternatives/#argh","text":"has similar goals as to ease up using argparser. doesn't support type hints. No recent releases.","title":"argh"},{"location":"2-alternatives/#typer","text":"if you are using click , I highly recommend you to check this library. it is neat and many features are drawn from it. doesn't support loading help text for arguments from docstrings.","title":"typer"},{"location":"2-alternatives/#invoke","text":"doesn't support type hints.","title":"invoke"},{"location":"2-alternatives/#cliche","text":"has similar goals. doesn't cover much use cases as arger .","title":"cliche"},{"location":"2-alternatives/#cliar","text":"no docstring support for help argument.","title":"cliar"},{"location":"2-alternatives/#recommended-alternatives","text":"Projects that I highly recommend you to checkout. clize nuclear defopt","title":"Recommended Alternatives"},{"location":"3-api-docs/","text":"Reference Arger Contains one (parser) or more commands (subparsers). __init__ ( self , func = None , version = None , sub_parser_title = 'commands' , formatter_class =< class ' argparse . ArgumentDefaultsHelpFormatter '>, exceptions_to_catch=(), _doc_str=None, _level=0, **kwargs) special Parameters: Name Type Description Default func Optional[Callable] A callable to parse root parser's arguments. None version Optional[str] adds --version flag. None sub_parser_title sub-parser title to pass. 'commands' exceptions_to_catch Sequence[Type[Exception]] exceptions to catch and print its message. Will exit with 1 and will hide traceback. () _doc_str Optional[arger.docstring.DocstringTp] internally passed from arger.add_cmd None _level internal 0 **kwargs all the arguments that are supported by ArgumentParser {} Examples: adding version flag version = '%(prog)s 2.0' Arger() equals to Arger().add_argument('--version', action='version', version=version) Source code in arger/main.py def __init__ ( self , func : tp . Optional [ tp . Callable ] = None , version : tp . Optional [ str ] = None , sub_parser_title = \"commands\" , formatter_class = ap . ArgumentDefaultsHelpFormatter , exceptions_to_catch : tp . Sequence [ tp . Type [ Exception ]] = (), _doc_str : tp . Optional [ DocstringTp ] = None , _level = 0 , ** kwargs , ): \"\"\" Args: func: A callable to parse root parser's arguments. version: adds --version flag. sub_parser_title: sub-parser title to pass. exceptions_to_catch: exceptions to catch and print its message. Will exit with 1 and will hide traceback. _doc_str: internally passed from arger.add_cmd _level: internal **kwargs: all the arguments that are supported by [ArgumentParser](https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser) Examples: adding version flag version = '%(prog)s 2.0' Arger() equals to Arger().add_argument('--version', action='version', version=version) \"\"\" kwargs . setdefault ( \"formatter_class\" , formatter_class ) self . sub_parser_title = sub_parser_title self . sub_parser : tp . Optional [ ap . _SubParsersAction ] = None self . args : tp . Dict [ str , Argument ] = OrderedDict () docstr = DocstringParser . parse ( func ) if _doc_str is None else _doc_str kwargs . setdefault ( \"description\" , docstr . description ) kwargs . setdefault ( \"epilog\" , docstr . epilog ) super () . __init__ ( ** kwargs ) self . set_defaults ( ** { LEVEL : _level }) self . func = func self . exceptions_to_catch = exceptions_to_catch self . _add_arguments ( docstr , _level ) if version : self . add_argument ( \"--version\" , action = \"version\" , version = version ) add_cmd ( self , func = None , ** kwargs ) Create a sub-command from the function. All its parameters will be converted to CLI args wrt their types. Parameters: Name Type Description Default func function to create sub-command from. None **kwargs will get passed to subparser.add_parser method {} Returns Arger: A new parser from the function is returned. Source code in arger/main.py def add_cmd ( self , func = None , ** kwargs ): \"\"\"Create a sub-command from the function. All its parameters will be converted to CLI args wrt their types. Args: func: function to create sub-command from. **kwargs: will get passed to `subparser.add_parser` method Returns Arger: A new parser from the function is returned. \"\"\" if not self . sub_parser : self . sub_parser = self . add_subparsers ( title = self . sub_parser_title ) def _wrapper ( fn : tp . Callable ) -> \"Arger\" : docstr = DocstringParser . parse ( fn ) arger = self . sub_parser . add_parser ( # type: ignore name = kwargs . pop ( \"name\" , fn . __name__ ), help = kwargs . pop ( \"help\" , docstr . description ), func = fn , _doc_str = docstr , _level = self . get_default ( LEVEL ) + 1 , ** kwargs , ) return tp . cast ( Arger , arger ) if func is None : return _wrapper return _wrapper ( func ) init ( ** kwargs ) classmethod Create parser from function as a decorator. Parameters: Name Type Description Default **kwargs will be passed to arger.Arger initialisation. {} Source code in arger/main.py @classmethod def init ( cls , ** kwargs ) -> tp . Callable [[ tp . Callable ], \"Arger\" ]: \"\"\"Create parser from function as a decorator. Args: **kwargs: will be passed to arger.Arger initialisation. \"\"\" def _wrapper ( fn : tp . Callable ): return cls ( func = fn , ** kwargs ) return _wrapper run ( self , * args , * , capture_sys = True , ** kwargs ) Parse cli and dispatch functions. Parameters: Name Type Description Default capture_sys whether to capture sys.argv if args not passed. Useful during testing. True *args str The arguments will be passed onto as self.parse_args(args) . () **kwargs will get passed to parse_args method {} Source code in arger/main.py def run ( self , * args : str , capture_sys = True , ** kwargs ) -> ap . Namespace : \"\"\"Parse cli and dispatch functions. Args: capture_sys: whether to capture `sys.argv` if `args` not passed. Useful during testing. *args: The arguments will be passed onto as `self.parse_args(args)`. **kwargs: will get passed to `parse_args` method \"\"\" if not args and capture_sys : args = tuple ( sys . argv [ 1 :]) namespace = self . parse_args ( args , ** kwargs ) kwargs = vars ( namespace ) kwargs [ NS_PREFIX ] = copy . copy ( namespace ) kwargs [ \"_arger_\" ] = self # dispatch all functions as in hierarchy for level in range ( kwargs . get ( LEVEL , 0 ) + 1 ): func_name = f \" { FUNC_PREFIX }{ level } \" if func_name in kwargs : kwargs [ func_name ]( ** kwargs ) return namespace Argument __init__ ( self , * , type = None , metavar = None , required = None , nargs = None , const = None , choices = None , action = None , flags = (), ** kwargs ) special Represent positional arguments to the command that are required by default. Analogous to ArgumentParser.add_argument Parameters: Name Type Description Default type Union[Callable[[str], ~T], argparse.FileType] The type to which the command-line argument should be converted. Got from annotation. Use Argument class itself in case you want to pass variables to Arger.add_argument . Ex: typing.cast(int, Argument(type=int)) . If not passed then it is returned as str. None metavar str A name for the argument in usage messages. None nargs Union[int, str] The number of command-line arguments that should be consumed. to be generated from the type-hint. Ex: types and how they are converted to nargs Tuple[str, ...] -> nargs='+' Tuple[str, str] -> nargs=2 List[str]|tuple|list -> nargs=* Note: even though Tuple[str,...] doesn't mean one or more, it is just to make nargs=+ easier to add. None const Any covered by type-hint and default value given None choices Iterable[Any] Use enum.Enum as the typehint to generate choices automatically. None action Union[str, Type[argparse.Action]] The basic type of action to be taken when this argument is encountered at the command line. None flags Sequence[str] It will be generated from the argument name. In case one wants to override the generated flags, could be done by passing them. () default tp.Any The value produced if the argument is absent from the command line. The default value assigned to a keyword argument helps determine the type of option and action if it is not type annotated. The default value is assigned directly to the parser's default for that option. In addition, it determines the ArgumentParser action a default value of False implies store_true, while True implies store_false. If the default value is a list, the action is append (multiple instances of that option are permitted). Strings or None imply a store action. required kwargs Any it is delegated to ArgumentParser.add_argument method. {} Source code in arger/main.py def __init__ ( self , * , type : tp . Union [ tp . Callable [[ str ], tp_utils . T ], ap . FileType ] = None , metavar : str = None , required : bool = None , nargs : tp . Union [ int , str ] = None , const : tp . Any = None , choices : tp . Iterable [ tp . Any ] = None , action : tp . Union [ str , tp . Type [ ap . Action ]] = None , flags : tp . Sequence [ str ] = (), ** kwargs : tp . Any , ): \"\"\"Represent positional arguments to the command that are required by default. Analogous to [ArgumentParser.add_argument](https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument) Args: type: The type to which the command-line argument should be converted. Got from annotation. Use Argument class itself in case you want to pass variables to `Arger.add_argument`. Ex: `typing.cast(int, Argument(type=int))`. If not passed then it is returned as str. metavar: A name for the argument in usage messages. nargs: The number of command-line arguments that should be consumed. to be generated from the type-hint. Ex: types and how they are converted to nargs * `Tuple[str, ...] -> nargs='+'` * `Tuple[str, str] -> nargs=2` * `List[str]|tuple|list -> nargs=*` Note: even though Tuple[str,...] doesn't mean one or more, it is just to make `nargs=+` easier to add. const: covered by type-hint and default value given choices: Use `enum.Enum` as the typehint to generate choices automatically. action: The basic type of action to be taken when this argument is encountered at the command line. flags: It will be generated from the argument name. In case one wants to override the generated flags, could be done by passing them. default (tp.Any): The value produced if the argument is absent from the command line. * The default value assigned to a keyword argument helps determine the type of option and action if it is not type annotated. * The default value is assigned directly to the parser's default for that option. * In addition, it determines the ArgumentParser action * a default value of False implies store_true, while True implies store_false. * If the default value is a list, the action is append (multiple instances of that option are permitted). * Strings or None imply a store action. kwargs: it is delegated to `ArgumentParser.add_argument` method. \"\"\" for var_name in ( \"type\" , \"metavar\" , \"required\" , \"nargs\" , \"const\" , \"choices\" , \"action\" , ): value = locals ()[ var_name ] if value is not None : kwargs [ var_name ] = value self . flags = flags self . kwargs = kwargs","title":"Reference"},{"location":"3-api-docs/#reference","text":"","title":"Reference"},{"location":"3-api-docs/#arger","text":"Contains one (parser) or more commands (subparsers).","title":"Arger"},{"location":"3-api-docs/#arger.main.Arger.__init__","text":"Parameters: Name Type Description Default func Optional[Callable] A callable to parse root parser's arguments. None version Optional[str] adds --version flag. None sub_parser_title sub-parser title to pass. 'commands' exceptions_to_catch Sequence[Type[Exception]] exceptions to catch and print its message. Will exit with 1 and will hide traceback. () _doc_str Optional[arger.docstring.DocstringTp] internally passed from arger.add_cmd None _level internal 0 **kwargs all the arguments that are supported by ArgumentParser {} Examples: adding version flag version = '%(prog)s 2.0' Arger() equals to Arger().add_argument('--version', action='version', version=version) Source code in arger/main.py def __init__ ( self , func : tp . Optional [ tp . Callable ] = None , version : tp . Optional [ str ] = None , sub_parser_title = \"commands\" , formatter_class = ap . ArgumentDefaultsHelpFormatter , exceptions_to_catch : tp . Sequence [ tp . Type [ Exception ]] = (), _doc_str : tp . Optional [ DocstringTp ] = None , _level = 0 , ** kwargs , ): \"\"\" Args: func: A callable to parse root parser's arguments. version: adds --version flag. sub_parser_title: sub-parser title to pass. exceptions_to_catch: exceptions to catch and print its message. Will exit with 1 and will hide traceback. _doc_str: internally passed from arger.add_cmd _level: internal **kwargs: all the arguments that are supported by [ArgumentParser](https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser) Examples: adding version flag version = '%(prog)s 2.0' Arger() equals to Arger().add_argument('--version', action='version', version=version) \"\"\" kwargs . setdefault ( \"formatter_class\" , formatter_class ) self . sub_parser_title = sub_parser_title self . sub_parser : tp . Optional [ ap . _SubParsersAction ] = None self . args : tp . Dict [ str , Argument ] = OrderedDict () docstr = DocstringParser . parse ( func ) if _doc_str is None else _doc_str kwargs . setdefault ( \"description\" , docstr . description ) kwargs . setdefault ( \"epilog\" , docstr . epilog ) super () . __init__ ( ** kwargs ) self . set_defaults ( ** { LEVEL : _level }) self . func = func self . exceptions_to_catch = exceptions_to_catch self . _add_arguments ( docstr , _level ) if version : self . add_argument ( \"--version\" , action = \"version\" , version = version )","title":"__init__()"},{"location":"3-api-docs/#arger.main.Arger.add_cmd","text":"Create a sub-command from the function. All its parameters will be converted to CLI args wrt their types. Parameters: Name Type Description Default func function to create sub-command from. None **kwargs will get passed to subparser.add_parser method {} Returns Arger: A new parser from the function is returned. Source code in arger/main.py def add_cmd ( self , func = None , ** kwargs ): \"\"\"Create a sub-command from the function. All its parameters will be converted to CLI args wrt their types. Args: func: function to create sub-command from. **kwargs: will get passed to `subparser.add_parser` method Returns Arger: A new parser from the function is returned. \"\"\" if not self . sub_parser : self . sub_parser = self . add_subparsers ( title = self . sub_parser_title ) def _wrapper ( fn : tp . Callable ) -> \"Arger\" : docstr = DocstringParser . parse ( fn ) arger = self . sub_parser . add_parser ( # type: ignore name = kwargs . pop ( \"name\" , fn . __name__ ), help = kwargs . pop ( \"help\" , docstr . description ), func = fn , _doc_str = docstr , _level = self . get_default ( LEVEL ) + 1 , ** kwargs , ) return tp . cast ( Arger , arger ) if func is None : return _wrapper return _wrapper ( func )","title":"add_cmd()"},{"location":"3-api-docs/#arger.main.Arger.init","text":"Create parser from function as a decorator. Parameters: Name Type Description Default **kwargs will be passed to arger.Arger initialisation. {} Source code in arger/main.py @classmethod def init ( cls , ** kwargs ) -> tp . Callable [[ tp . Callable ], \"Arger\" ]: \"\"\"Create parser from function as a decorator. Args: **kwargs: will be passed to arger.Arger initialisation. \"\"\" def _wrapper ( fn : tp . Callable ): return cls ( func = fn , ** kwargs ) return _wrapper","title":"init()"},{"location":"3-api-docs/#arger.main.Arger.run","text":"Parse cli and dispatch functions. Parameters: Name Type Description Default capture_sys whether to capture sys.argv if args not passed. Useful during testing. True *args str The arguments will be passed onto as self.parse_args(args) . () **kwargs will get passed to parse_args method {} Source code in arger/main.py def run ( self , * args : str , capture_sys = True , ** kwargs ) -> ap . Namespace : \"\"\"Parse cli and dispatch functions. Args: capture_sys: whether to capture `sys.argv` if `args` not passed. Useful during testing. *args: The arguments will be passed onto as `self.parse_args(args)`. **kwargs: will get passed to `parse_args` method \"\"\" if not args and capture_sys : args = tuple ( sys . argv [ 1 :]) namespace = self . parse_args ( args , ** kwargs ) kwargs = vars ( namespace ) kwargs [ NS_PREFIX ] = copy . copy ( namespace ) kwargs [ \"_arger_\" ] = self # dispatch all functions as in hierarchy for level in range ( kwargs . get ( LEVEL , 0 ) + 1 ): func_name = f \" { FUNC_PREFIX }{ level } \" if func_name in kwargs : kwargs [ func_name ]( ** kwargs ) return namespace","title":"run()"},{"location":"3-api-docs/#argument","text":"","title":"Argument"},{"location":"3-api-docs/#arger.main.Argument.__init__","text":"Represent positional arguments to the command that are required by default. Analogous to ArgumentParser.add_argument Parameters: Name Type Description Default type Union[Callable[[str], ~T], argparse.FileType] The type to which the command-line argument should be converted. Got from annotation. Use Argument class itself in case you want to pass variables to Arger.add_argument . Ex: typing.cast(int, Argument(type=int)) . If not passed then it is returned as str. None metavar str A name for the argument in usage messages. None nargs Union[int, str] The number of command-line arguments that should be consumed. to be generated from the type-hint. Ex: types and how they are converted to nargs Tuple[str, ...] -> nargs='+' Tuple[str, str] -> nargs=2 List[str]|tuple|list -> nargs=* Note: even though Tuple[str,...] doesn't mean one or more, it is just to make nargs=+ easier to add. None const Any covered by type-hint and default value given None choices Iterable[Any] Use enum.Enum as the typehint to generate choices automatically. None action Union[str, Type[argparse.Action]] The basic type of action to be taken when this argument is encountered at the command line. None flags Sequence[str] It will be generated from the argument name. In case one wants to override the generated flags, could be done by passing them. () default tp.Any The value produced if the argument is absent from the command line. The default value assigned to a keyword argument helps determine the type of option and action if it is not type annotated. The default value is assigned directly to the parser's default for that option. In addition, it determines the ArgumentParser action a default value of False implies store_true, while True implies store_false. If the default value is a list, the action is append (multiple instances of that option are permitted). Strings or None imply a store action. required kwargs Any it is delegated to ArgumentParser.add_argument method. {} Source code in arger/main.py def __init__ ( self , * , type : tp . Union [ tp . Callable [[ str ], tp_utils . T ], ap . FileType ] = None , metavar : str = None , required : bool = None , nargs : tp . Union [ int , str ] = None , const : tp . Any = None , choices : tp . Iterable [ tp . Any ] = None , action : tp . Union [ str , tp . Type [ ap . Action ]] = None , flags : tp . Sequence [ str ] = (), ** kwargs : tp . Any , ): \"\"\"Represent positional arguments to the command that are required by default. Analogous to [ArgumentParser.add_argument](https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument) Args: type: The type to which the command-line argument should be converted. Got from annotation. Use Argument class itself in case you want to pass variables to `Arger.add_argument`. Ex: `typing.cast(int, Argument(type=int))`. If not passed then it is returned as str. metavar: A name for the argument in usage messages. nargs: The number of command-line arguments that should be consumed. to be generated from the type-hint. Ex: types and how they are converted to nargs * `Tuple[str, ...] -> nargs='+'` * `Tuple[str, str] -> nargs=2` * `List[str]|tuple|list -> nargs=*` Note: even though Tuple[str,...] doesn't mean one or more, it is just to make `nargs=+` easier to add. const: covered by type-hint and default value given choices: Use `enum.Enum` as the typehint to generate choices automatically. action: The basic type of action to be taken when this argument is encountered at the command line. flags: It will be generated from the argument name. In case one wants to override the generated flags, could be done by passing them. default (tp.Any): The value produced if the argument is absent from the command line. * The default value assigned to a keyword argument helps determine the type of option and action if it is not type annotated. * The default value is assigned directly to the parser's default for that option. * In addition, it determines the ArgumentParser action * a default value of False implies store_true, while True implies store_false. * If the default value is a list, the action is append (multiple instances of that option are permitted). * Strings or None imply a store action. kwargs: it is delegated to `ArgumentParser.add_argument` method. \"\"\" for var_name in ( \"type\" , \"metavar\" , \"required\" , \"nargs\" , \"const\" , \"choices\" , \"action\" , ): value = locals ()[ var_name ] if value is not None : kwargs [ var_name ] = value self . flags = flags self . kwargs = kwargs","title":"__init__()"},{"location":"changelog/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . v1.4.2 - 2021-10-16 Compare with v1.3.8 Bug Fixes Handle py310 help out change ( cf3a570 by Noortheen Raja). Github py version ( 04912ec by Noortheen Raja). Qa errors ( 2d53c81 by Noortheen Raja). v1.3.8 - 2021-04-11 Compare with v1.3.7 Bug Fixes Handle failing mkdocs build ( 8d72d4d by Noortheen Raja). v1.3.7 - 2021-04-11 Compare with v1.3.6 Bug Fixes Typing.optional kwarg handling ( 76978c3 by Noortheen Raja). Related issues/PRs: #2 v1.3.6 - 2021-02-17 Compare with v1.3.5 Bug Fixes Failing pytkdocs api docstring getter ( 7f2222c by Noortheen Raja). v1.3.5 - 2021-02-16 Compare with v1.3.4 Bug Fixes Py36 compatibility for get_origin(annotated) ( 20abc00 by Noortheen Raja). v1.3.4 - 2021-02-16 Compare with v1.3.1 v1.3.1 - 2021-02-16 Compare with v1.3.0 Features Use annotated for arguments ( ddbdf38 by Noortheen Raja). v1.3.0 - 2021-02-16 Compare with v1.2.11 Bug Fixes Py-lint errors ( 0fa651a by Noortheen Raja). v1.2.11 - 2021-02-16 Compare with v1.2.10 Bug Fixes Py36 literal compatibilty ( 2baf271 by Noortheen Raja). v1.2.10 - 2021-02-16 Compare with v1.2.9 Features Add literal support for choices ( 82322f7 by Noortheen Raja). Related issues/PRs: #1 v1.2.9 - 2021-01-27 Compare with v1.2.8 Bug Fixes When param:bool=true used raises error ( 1537b41 by Noortheen Raja). v1.2.8 - 2021-01-02 Compare with v1.2.7 Code Refactoring Split version to new module ( e60b059 by Noortheen Raja). v1.2.7 - 2020-12-23 Compare with v1.2.6 Features Add support for typing.optional <-> nargs=\"?\" ( 12ab8c7 by Noortheen Raja). v1.2.6 - 2020-12-16 Compare with v1.2.5 v1.2.5 - 2020-12-16 Compare with v1.2.4 v1.2.4 - 2020-12-07 Compare with v1.2.3 v1.2.3 - 2020-12-07 Compare with v1.2.2 v1.2.2 - 2020-12-07 Compare with v1.2.1 v1.2.1 - 2020-12-07 Compare with v1.2.0 Features Support add arger.add_commands method ( a9cb3fa by Noortheen Raja). v1.2.0 - 2020-12-06 Compare with v1.1.0 v1.1.0 - 2020-12-05 Compare with v1.0.11 Features Option to customize sub-commands title ( 982dab6 by Noortheen Raja). v1.0.11 - 2020-12-04 Compare with v1.0.10 Bug Fixes When *varargs used, it caused incorrect function dispatch ( 0209820 by Noortheen Raja). v1.0.10 - 2020-11-28 Compare with v1.0.9 v1.0.9 - 2020-11-28 Compare with v1.0.8 Code Refactoring Use _init_subclass to register docstring parsers ( ac486bd by Noortheen Raja). Features Use prefix_chars settings to generate flags ( c9eabb2 by Noortheen Raja). v1.0.8 - 2020-11-11 Compare with v1.0.7 Bug Fixes Update numpy docstring parser ( b479611 by Noortheen Raja). v1.0.7 - 2020-11-09 Compare with v1.0.6 Code Refactoring Merge funcs and maian modules ( fd0ab1c by Noortheen Raja). Remove parsedfunc type ( 37810d6 by Noortheen Raja). Merge classes that handle argument and option creation ( 023877d by Noortheen Raja). Update typeaction handling vararg ( 351979f by Noortheen Raja). Replace namedtuple param with inspect.parameter ( 545cb80 by Noortheen Raja). Merge into single module parsers ( 73e4f08 by Noortheen Raja). Update argument update funcs ( 08f9080 by Noortheen Raja). Reduce number of modules ( ca4471f by Noortheen Raja). Update usage of types inside docstrings ( 7e2f20a by Noortheen Raja). Move code from types to typing_utils ( b9c779c by Noortheen Raja). Features Add version flag/action by passing version string to arger ( 286328b by Noortheen Raja). Create subcommands as soon as arger initiated ( 9848e4e by Noortheen Raja). Publish docs to github-pages ( 57894fa by Noortheen Raja). v1.0.6 - 2020-11-01 Compare with v1.0.5 Features Add python 3.9 support ( c647243 by Noortheen Raja). v1.0.5 - 2020-11-01 Compare with v1.0.3 v1.0.3 - 2020-11-01 Compare with v1.0.2 Features Implement skipping private arguments ( 24d7404 by Noortheen Raja). v1.0.2 - 2020-11-01 Compare with v1.0.1 Features Add py39 to ci tests ( ec32e84 by Noortheen Raja). v1.0.1 - 2020-11-01 Compare with v0.4.1 Bug Fixes Py36 compat with re.pattern ( c695861 by Noortheen Raja). Code Refactoring Rewrite arger using new docstring parser ( 9cd93a5 by Noortheen Raja). Update docstring parser and add tests ( 3d9d681 by Noortheen Raja). Remove external dependency to parse docstring ( ac72e9f by Noortheen Raja). Features First stable release ( fc6e935 by Noortheen Raja). Any level of nested commands will get dispatched ( 9e579b1 by Noortheen Raja). Use notebook for testing examples ( 3ee4310 by Noortheen Raja). v0.4.1 - 2020-04-18 Compare with v0.4.0 Bug Fixes Mypy errors ( 09111b0 by Noortheen Raja). v0.4.0 - 2020-04-18 Compare with v0.3.0 Bug Fixes Py36 compatibility ( fe72990 by Noortheen Raja). Variable arg handling ( aaa7109 by Noortheen Raja). Code Refactoring Inherit option from argument ( c581cb9 by Noortheen Raja). Update typing-utils to work on py36 ( ec6f40a by Noortheen Raja). Update parser functions ( 3563223 by Noortheen Raja). Features Add support for more complex types ( 584e530 by Noortheen Raja). Add for tuple/list support ( 895eb9c by Noortheen Raja). v0.3.0 - 2020-04-16 Compare with v0.2.4 Code Refactoring Reduce complexity in parser function ( 2c2d586 by Noortheen Raja). Features Implement mkdocs ( 6ee7e70 by Noortheen Raja). Add support for variadict arguments ( dc857c4 by Noortheen Raja). v0.2.4 - 2020-04-14 Compare with v0.2.3 Bug Fixes Setting flags only when not defined ( c9f63d0 by Noortheen Raja). v0.2.3 - 2020-04-14 Compare with v0.2.2 Bug Fixes Using option to define arguments ( ed87eec by Noortheen Raja). Code Refactoring Rename arger class module ( b8a45d1 by Noortheen Raja). Features Use option for populating arguments ( aef46e7 by Noortheen Raja). v0.2.2 - 2020-04-13 Compare with v0.2.1 v0.2.1 - 2020-04-13 Compare with v0.2.0 Bug Fixes Handle tests passing sys.argv ( 9226d97 by Noortheen Raja). v0.2.0 - 2020-04-13 Compare with v0.1.3 Features Sub-command with a root context function ( 0c9d19d by Noortheen Raja). Add python < 37 compatible type checks ( f478771 by Noortheen Raja). Call nested commands ( 662d05a by Noortheen Raja). Add ability to add nested commands ( 923a4a0 by Noortheen Raja). v0.1.3 - 2020-04-11 Compare with v0.1.2 v0.1.2 - 2020-04-11 Compare with v0.1.1 v0.1.1 - 2020-04-11 Compare with 0.1 0.1 - 2020-04-11 Compare with first commit Bug Fixes Recognise type from typehint and default value ( 405cfad by Noortheen Raja). Mypy type errors ( 522954c by Noortheen Raja). Test workflow ( 951e23e by Noortheen Raja). Code Refactoring Add arger structs ( 6722d7a by Noortheen Raja). Remove notebooks folder ( d7f303b by Noortheen Raja). Move out docstring to sub functions ( e7ecd49 by Noortheen Raja). Features Implement single function dispatch ( 171e871 by Noortheen Raja). Make arger work with single or multi functions ( 5299fba by Noortheen Raja). Implement parser ( 1fd04ad by Noortheen Raja). Add action to publish package ( e85fe08 by Noortheen Raja). Add github actions for testing and linting ( d9ea90d by Noortheen Raja). Add boilerplate from ( 0e07f27 by Noortheen Raja).","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#v142-2021-10-16","text":"Compare with v1.3.8","title":"v1.4.2 - 2021-10-16"},{"location":"changelog/#bug-fixes","text":"Handle py310 help out change ( cf3a570 by Noortheen Raja). Github py version ( 04912ec by Noortheen Raja). Qa errors ( 2d53c81 by Noortheen Raja).","title":"Bug Fixes"},{"location":"changelog/#v138-2021-04-11","text":"Compare with v1.3.7","title":"v1.3.8 - 2021-04-11"},{"location":"changelog/#bug-fixes_1","text":"Handle failing mkdocs build ( 8d72d4d by Noortheen Raja).","title":"Bug Fixes"},{"location":"changelog/#v137-2021-04-11","text":"Compare with v1.3.6","title":"v1.3.7 - 2021-04-11"},{"location":"changelog/#bug-fixes_2","text":"Typing.optional kwarg handling ( 76978c3 by Noortheen Raja). Related issues/PRs: #2","title":"Bug Fixes"},{"location":"changelog/#v136-2021-02-17","text":"Compare with v1.3.5","title":"v1.3.6 - 2021-02-17"},{"location":"changelog/#bug-fixes_3","text":"Failing pytkdocs api docstring getter ( 7f2222c by Noortheen Raja).","title":"Bug Fixes"},{"location":"changelog/#v135-2021-02-16","text":"Compare with v1.3.4","title":"v1.3.5 - 2021-02-16"},{"location":"changelog/#bug-fixes_4","text":"Py36 compatibility for get_origin(annotated) ( 20abc00 by Noortheen Raja).","title":"Bug Fixes"},{"location":"changelog/#v134-2021-02-16","text":"Compare with v1.3.1","title":"v1.3.4 - 2021-02-16"},{"location":"changelog/#v131-2021-02-16","text":"Compare with v1.3.0","title":"v1.3.1 - 2021-02-16"},{"location":"changelog/#features","text":"Use annotated for arguments ( ddbdf38 by Noortheen Raja).","title":"Features"},{"location":"changelog/#v130-2021-02-16","text":"Compare with v1.2.11","title":"v1.3.0 - 2021-02-16"},{"location":"changelog/#bug-fixes_5","text":"Py-lint errors ( 0fa651a by Noortheen Raja).","title":"Bug Fixes"},{"location":"changelog/#v1211-2021-02-16","text":"Compare with v1.2.10","title":"v1.2.11 - 2021-02-16"},{"location":"changelog/#bug-fixes_6","text":"Py36 literal compatibilty ( 2baf271 by Noortheen Raja).","title":"Bug Fixes"},{"location":"changelog/#v1210-2021-02-16","text":"Compare with v1.2.9","title":"v1.2.10 - 2021-02-16"},{"location":"changelog/#features_1","text":"Add literal support for choices ( 82322f7 by Noortheen Raja). Related issues/PRs: #1","title":"Features"},{"location":"changelog/#v129-2021-01-27","text":"Compare with v1.2.8","title":"v1.2.9 - 2021-01-27"},{"location":"changelog/#bug-fixes_7","text":"When param:bool=true used raises error ( 1537b41 by Noortheen Raja).","title":"Bug Fixes"},{"location":"changelog/#v128-2021-01-02","text":"Compare with v1.2.7","title":"v1.2.8 - 2021-01-02"},{"location":"changelog/#code-refactoring","text":"Split version to new module ( e60b059 by Noortheen Raja).","title":"Code Refactoring"},{"location":"changelog/#v127-2020-12-23","text":"Compare with v1.2.6","title":"v1.2.7 - 2020-12-23"},{"location":"changelog/#features_2","text":"Add support for typing.optional <-> nargs=\"?\" ( 12ab8c7 by Noortheen Raja).","title":"Features"},{"location":"changelog/#v126-2020-12-16","text":"Compare with v1.2.5","title":"v1.2.6 - 2020-12-16"},{"location":"changelog/#v125-2020-12-16","text":"Compare with v1.2.4","title":"v1.2.5 - 2020-12-16"},{"location":"changelog/#v124-2020-12-07","text":"Compare with v1.2.3","title":"v1.2.4 - 2020-12-07"},{"location":"changelog/#v123-2020-12-07","text":"Compare with v1.2.2","title":"v1.2.3 - 2020-12-07"},{"location":"changelog/#v122-2020-12-07","text":"Compare with v1.2.1","title":"v1.2.2 - 2020-12-07"},{"location":"changelog/#v121-2020-12-07","text":"Compare with v1.2.0","title":"v1.2.1 - 2020-12-07"},{"location":"changelog/#features_3","text":"Support add arger.add_commands method ( a9cb3fa by Noortheen Raja).","title":"Features"},{"location":"changelog/#v120-2020-12-06","text":"Compare with v1.1.0","title":"v1.2.0 - 2020-12-06"},{"location":"changelog/#v110-2020-12-05","text":"Compare with v1.0.11","title":"v1.1.0 - 2020-12-05"},{"location":"changelog/#features_4","text":"Option to customize sub-commands title ( 982dab6 by Noortheen Raja).","title":"Features"},{"location":"changelog/#v1011-2020-12-04","text":"Compare with v1.0.10","title":"v1.0.11 - 2020-12-04"},{"location":"changelog/#bug-fixes_8","text":"When *varargs used, it caused incorrect function dispatch ( 0209820 by Noortheen Raja).","title":"Bug Fixes"},{"location":"changelog/#v1010-2020-11-28","text":"Compare with v1.0.9","title":"v1.0.10 - 2020-11-28"},{"location":"changelog/#v109-2020-11-28","text":"Compare with v1.0.8","title":"v1.0.9 - 2020-11-28"},{"location":"changelog/#code-refactoring_1","text":"Use _init_subclass to register docstring parsers ( ac486bd by Noortheen Raja).","title":"Code Refactoring"},{"location":"changelog/#features_5","text":"Use prefix_chars settings to generate flags ( c9eabb2 by Noortheen Raja).","title":"Features"},{"location":"changelog/#v108-2020-11-11","text":"Compare with v1.0.7","title":"v1.0.8 - 2020-11-11"},{"location":"changelog/#bug-fixes_9","text":"Update numpy docstring parser ( b479611 by Noortheen Raja).","title":"Bug Fixes"},{"location":"changelog/#v107-2020-11-09","text":"Compare with v1.0.6","title":"v1.0.7 - 2020-11-09"},{"location":"changelog/#code-refactoring_2","text":"Merge funcs and maian modules ( fd0ab1c by Noortheen Raja). Remove parsedfunc type ( 37810d6 by Noortheen Raja). Merge classes that handle argument and option creation ( 023877d by Noortheen Raja). Update typeaction handling vararg ( 351979f by Noortheen Raja). Replace namedtuple param with inspect.parameter ( 545cb80 by Noortheen Raja). Merge into single module parsers ( 73e4f08 by Noortheen Raja). Update argument update funcs ( 08f9080 by Noortheen Raja). Reduce number of modules ( ca4471f by Noortheen Raja). Update usage of types inside docstrings ( 7e2f20a by Noortheen Raja). Move code from types to typing_utils ( b9c779c by Noortheen Raja).","title":"Code Refactoring"},{"location":"changelog/#features_6","text":"Add version flag/action by passing version string to arger ( 286328b by Noortheen Raja). Create subcommands as soon as arger initiated ( 9848e4e by Noortheen Raja). Publish docs to github-pages ( 57894fa by Noortheen Raja).","title":"Features"},{"location":"changelog/#v106-2020-11-01","text":"Compare with v1.0.5","title":"v1.0.6 - 2020-11-01"},{"location":"changelog/#features_7","text":"Add python 3.9 support ( c647243 by Noortheen Raja).","title":"Features"},{"location":"changelog/#v105-2020-11-01","text":"Compare with v1.0.3","title":"v1.0.5 - 2020-11-01"},{"location":"changelog/#v103-2020-11-01","text":"Compare with v1.0.2","title":"v1.0.3 - 2020-11-01"},{"location":"changelog/#features_8","text":"Implement skipping private arguments ( 24d7404 by Noortheen Raja).","title":"Features"},{"location":"changelog/#v102-2020-11-01","text":"Compare with v1.0.1","title":"v1.0.2 - 2020-11-01"},{"location":"changelog/#features_9","text":"Add py39 to ci tests ( ec32e84 by Noortheen Raja).","title":"Features"},{"location":"changelog/#v101-2020-11-01","text":"Compare with v0.4.1","title":"v1.0.1 - 2020-11-01"},{"location":"changelog/#bug-fixes_10","text":"Py36 compat with re.pattern ( c695861 by Noortheen Raja).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_3","text":"Rewrite arger using new docstring parser ( 9cd93a5 by Noortheen Raja). Update docstring parser and add tests ( 3d9d681 by Noortheen Raja). Remove external dependency to parse docstring ( ac72e9f by Noortheen Raja).","title":"Code Refactoring"},{"location":"changelog/#features_10","text":"First stable release ( fc6e935 by Noortheen Raja). Any level of nested commands will get dispatched ( 9e579b1 by Noortheen Raja). Use notebook for testing examples ( 3ee4310 by Noortheen Raja).","title":"Features"},{"location":"changelog/#v041-2020-04-18","text":"Compare with v0.4.0","title":"v0.4.1 - 2020-04-18"},{"location":"changelog/#bug-fixes_11","text":"Mypy errors ( 09111b0 by Noortheen Raja).","title":"Bug Fixes"},{"location":"changelog/#v040-2020-04-18","text":"Compare with v0.3.0","title":"v0.4.0 - 2020-04-18"},{"location":"changelog/#bug-fixes_12","text":"Py36 compatibility ( fe72990 by Noortheen Raja). Variable arg handling ( aaa7109 by Noortheen Raja).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_4","text":"Inherit option from argument ( c581cb9 by Noortheen Raja). Update typing-utils to work on py36 ( ec6f40a by Noortheen Raja). Update parser functions ( 3563223 by Noortheen Raja).","title":"Code Refactoring"},{"location":"changelog/#features_11","text":"Add support for more complex types ( 584e530 by Noortheen Raja). Add for tuple/list support ( 895eb9c by Noortheen Raja).","title":"Features"},{"location":"changelog/#v030-2020-04-16","text":"Compare with v0.2.4","title":"v0.3.0 - 2020-04-16"},{"location":"changelog/#code-refactoring_5","text":"Reduce complexity in parser function ( 2c2d586 by Noortheen Raja).","title":"Code Refactoring"},{"location":"changelog/#features_12","text":"Implement mkdocs ( 6ee7e70 by Noortheen Raja). Add support for variadict arguments ( dc857c4 by Noortheen Raja).","title":"Features"},{"location":"changelog/#v024-2020-04-14","text":"Compare with v0.2.3","title":"v0.2.4 - 2020-04-14"},{"location":"changelog/#bug-fixes_13","text":"Setting flags only when not defined ( c9f63d0 by Noortheen Raja).","title":"Bug Fixes"},{"location":"changelog/#v023-2020-04-14","text":"Compare with v0.2.2","title":"v0.2.3 - 2020-04-14"},{"location":"changelog/#bug-fixes_14","text":"Using option to define arguments ( ed87eec by Noortheen Raja).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_6","text":"Rename arger class module ( b8a45d1 by Noortheen Raja).","title":"Code Refactoring"},{"location":"changelog/#features_13","text":"Use option for populating arguments ( aef46e7 by Noortheen Raja).","title":"Features"},{"location":"changelog/#v022-2020-04-13","text":"Compare with v0.2.1","title":"v0.2.2 - 2020-04-13"},{"location":"changelog/#v021-2020-04-13","text":"Compare with v0.2.0","title":"v0.2.1 - 2020-04-13"},{"location":"changelog/#bug-fixes_15","text":"Handle tests passing sys.argv ( 9226d97 by Noortheen Raja).","title":"Bug Fixes"},{"location":"changelog/#v020-2020-04-13","text":"Compare with v0.1.3","title":"v0.2.0 - 2020-04-13"},{"location":"changelog/#features_14","text":"Sub-command with a root context function ( 0c9d19d by Noortheen Raja). Add python < 37 compatible type checks ( f478771 by Noortheen Raja). Call nested commands ( 662d05a by Noortheen Raja). Add ability to add nested commands ( 923a4a0 by Noortheen Raja).","title":"Features"},{"location":"changelog/#v013-2020-04-11","text":"Compare with v0.1.2","title":"v0.1.3 - 2020-04-11"},{"location":"changelog/#v012-2020-04-11","text":"Compare with v0.1.1","title":"v0.1.2 - 2020-04-11"},{"location":"changelog/#v011-2020-04-11","text":"Compare with 0.1","title":"v0.1.1 - 2020-04-11"},{"location":"changelog/#01-2020-04-11","text":"Compare with first commit","title":"0.1 - 2020-04-11"},{"location":"changelog/#bug-fixes_16","text":"Recognise type from typehint and default value ( 405cfad by Noortheen Raja). Mypy type errors ( 522954c by Noortheen Raja). Test workflow ( 951e23e by Noortheen Raja).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_7","text":"Add arger structs ( 6722d7a by Noortheen Raja). Remove notebooks folder ( d7f303b by Noortheen Raja). Move out docstring to sub functions ( e7ecd49 by Noortheen Raja).","title":"Code Refactoring"},{"location":"changelog/#features_15","text":"Implement single function dispatch ( 171e871 by Noortheen Raja). Make arger work with single or multi functions ( 5299fba by Noortheen Raja). Implement parser ( 1fd04ad by Noortheen Raja). Add action to publish package ( e85fe08 by Noortheen Raja). Add github actions for testing and linting ( d9ea90d by Noortheen Raja). Add boilerplate from ( 0e07f27 by Noortheen Raja).","title":"Features"},{"location":"examples/1-single-function/","text":"Single function in a file named src.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from arger import Arger from argparse import Namespace from tests.utils import _reprint def main ( param1 : int , param2 : str , _namespace_ : Namespace , kw1 = None , kw2 = False ): \"\"\"Example function with types documented in the docstring. :param param1: The first parameter. :param param2: The second parameter. :param kw1: this is optional parameter. :param kw2: this is boolean. setting flag sets True. \"\"\" _reprint ( ** locals ()) arger = Arger ( main , prog = 'pytest' , # for testing purpose. otherwise not required ) if __name__ == '__main__' : arger . run ()","title":"Single function"},{"location":"examples/1-single-function/#single-function","text":"in a file named src.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from arger import Arger from argparse import Namespace from tests.utils import _reprint def main ( param1 : int , param2 : str , _namespace_ : Namespace , kw1 = None , kw2 = False ): \"\"\"Example function with types documented in the docstring. :param param1: The first parameter. :param param2: The second parameter. :param kw1: this is optional parameter. :param kw2: this is boolean. setting flag sets True. \"\"\" _reprint ( ** locals ()) arger = Arger ( main , prog = 'pytest' , # for testing purpose. otherwise not required ) if __name__ == '__main__' : arger . run ()","title":"Single function"},{"location":"examples/1-single-function/usage/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); 1 2 # Run help ! python src . py - h usage: pytest [-h] [-k KW1] [-w] param1 param2 Example function with types documented in the docstring. positional arguments: param1 The first parameter. param2 The second parameter. optional arguments: -h, --help show this help message and exit -k KW1, --kw1 KW1 this is optional parameter. (default: None) -w, --kw2 this is boolean. setting flag sets True. (default: False) 1 2 # ran with both positional arguments ! python src . py 10 p2 _namespace_ (<class 'argparse.Namespace'>): [('__func_0', '_dispatch'), ('__level__', 0), ('kw1', None), ('kw2', False), ('param1', 10), ('param2', 'p2')] kw1 (<class 'NoneType'>): None kw2 (<class 'bool'>): False param1 (<class 'int'>): 10 param2 (<class 'str'>): p2 1 2 # ran empty ! python src . py usage: pytest [-h] [-k KW1] [-w] param1 param2 pytest: error: the following arguments are required: param1, param2 1 2 # ran with invalid option ! python src . py -- invalid usage: pytest [-h] [-k KW1] [-w] param1 param2 pytest: error: the following arguments are required: param1, param2 1 2 # ran with invalid type ! python src . py p1 p2 usage: pytest [-h] [-k KW1] [-w] param1 param2 pytest: error: argument param1: invalid int value: 'p1'","title":"Usage"},{"location":"examples/2-sub-commands/","text":"Sub-commands in a file named src.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from arger import Arger from tests.utils import _reprint arger = Arger ( prog = 'pytest' , description = \"App Description goes here\" ) container = [] @arger . add_cmd def create ( name : str ): \"\"\"Create new test. :param name: Name of the test \"\"\" container . append ( container ) _reprint ( ** locals ()) @arger . add_cmd def remove ( * name : str ): \"\"\"Remove a test with variadic argument. :param name: tests to remove \"\"\" if name in container : container . remove ( remove ) _reprint ( ** locals ()) @arger . add_cmd def list (): \"\"\"List all tests.\"\"\" _reprint ( ** locals (), container = container ) if __name__ == '__main__' : arger . run ()","title":"Sub-commands"},{"location":"examples/2-sub-commands/#sub-commands","text":"in a file named src.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from arger import Arger from tests.utils import _reprint arger = Arger ( prog = 'pytest' , description = \"App Description goes here\" ) container = [] @arger . add_cmd def create ( name : str ): \"\"\"Create new test. :param name: Name of the test \"\"\" container . append ( container ) _reprint ( ** locals ()) @arger . add_cmd def remove ( * name : str ): \"\"\"Remove a test with variadic argument. :param name: tests to remove \"\"\" if name in container : container . remove ( remove ) _reprint ( ** locals ()) @arger . add_cmd def list (): \"\"\"List all tests.\"\"\" _reprint ( ** locals (), container = container ) if __name__ == '__main__' : arger . run ()","title":"Sub-commands"},{"location":"examples/2-sub-commands/usage/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); 1 2 # Run help ! python src . py - h usage: pytest [-h] {create,remove,list} ... App Description goes here optional arguments: -h, --help show this help message and exit commands: {create,remove,list} create Create new test. remove Remove a test with variadic argument. list List all tests. 1 2 # Run `create` help ! python src . py create - h usage: pytest create [-h] name Create new test. positional arguments: name Name of the test optional arguments: -h, --help show this help message and exit 1 2 # Run `remove` help ! python src . py remove - h usage: pytest remove [-h] [name [name ...]] Remove a test with variadic argument. positional arguments: name tests to remove (default: None) optional arguments: -h, --help show this help message and exit 1 2 # Run `list` help ! python src . py list - h usage: pytest list [-h] List all tests. optional arguments: -h, --help show this help message and exit 1 2 # Run `create` command ! python src . py create folder1 name (<class 'str'>): folder1 1 2 # Run `remove` command ! python src . py remove folder1 folder2 name (<class 'tuple'>): ('folder1', 'folder2') 1 2 # Run `list` command ! python src . py list container (<class 'list'>): []","title":"Usage"},{"location":"examples/3-arger-as-function/","text":"Arger from function in a file named src.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from typing import Optional from arger import Arger from tests.utils import _reprint ctx = {} @Arger . init ( prog = \"pytest\" ) # any argument to the parser def arger ( verbose = False , log = False , log_file : Optional [ str ] = None ): \"\"\"App Description goes here. :param verbose: verbose output :param log_file: name of the log file to write output \"\"\" ctx . update ( ** locals ()) container = [] @arger . add_cmd def create ( name : str ): \"\"\"Create new test. :param name: Name of the test \"\"\" container . append ( container ) _reprint ( ** locals (), ** ctx ) @arger . add_cmd def remove ( name : str ): \"\"\"Remove a test. :param name: Name of the test \"\"\" if remove in container : container . remove ( remove ) _reprint ( ** locals (), ** ctx ) @arger . add_cmd def list ( filter : Optional [ str ]): \"\"\"List all tests.\"\"\" _reprint ( ** locals (), container = container , ** ctx ) if __name__ == \"__main__\" : arger . run () The functions are converted to sub-commands while the function arger serves as the entrypoint. It will get executed before other sub-commands.","title":"Arger from function"},{"location":"examples/3-arger-as-function/#arger-from-function","text":"in a file named src.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from typing import Optional from arger import Arger from tests.utils import _reprint ctx = {} @Arger . init ( prog = \"pytest\" ) # any argument to the parser def arger ( verbose = False , log = False , log_file : Optional [ str ] = None ): \"\"\"App Description goes here. :param verbose: verbose output :param log_file: name of the log file to write output \"\"\" ctx . update ( ** locals ()) container = [] @arger . add_cmd def create ( name : str ): \"\"\"Create new test. :param name: Name of the test \"\"\" container . append ( container ) _reprint ( ** locals (), ** ctx ) @arger . add_cmd def remove ( name : str ): \"\"\"Remove a test. :param name: Name of the test \"\"\" if remove in container : container . remove ( remove ) _reprint ( ** locals (), ** ctx ) @arger . add_cmd def list ( filter : Optional [ str ]): \"\"\"List all tests.\"\"\" _reprint ( ** locals (), container = container , ** ctx ) if __name__ == \"__main__\" : arger . run () The functions are converted to sub-commands while the function arger serves as the entrypoint. It will get executed before other sub-commands.","title":"Arger from function"},{"location":"examples/3-arger-as-function/usage/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); 1 2 # Run help ! python src . py - h usage: pytest [-h] [-v] [-l] [-o LOG_FILE] {create,remove,list} ... App Description goes here. optional arguments: -h, --help show this help message and exit -v, --verbose verbose output (default: False) -l, --log -o LOG_FILE, --log-file LOG_FILE name of the log file to write output (default: None) commands: {create,remove,list} create Create new test. remove Remove a test. list List all tests. 1 2 # Run `create` help ! python src . py create - h usage: pytest create [-h] name Create new test. positional arguments: name Name of the test optional arguments: -h, --help show this help message and exit 1 2 # Run `remove` help ! python src . py remove - h usage: pytest remove [-h] name Remove a test. positional arguments: name Name of the test optional arguments: -h, --help show this help message and exit 1 2 # Run `list` help ! python src . py list - h usage: pytest list [-h] [filter] List all tests. positional arguments: filter optional arguments: -h, --help show this help message and exit 1 2 # Run `create` command ! python src . py create folder1 log (<class 'bool'>): False log_file (<class 'NoneType'>): None name (<class 'str'>): folder1 verbose (<class 'bool'>): False 1 2 # Run `remove` command ! python src . py remove folder1 log (<class 'bool'>): False log_file (<class 'NoneType'>): None name (<class 'str'>): folder1 verbose (<class 'bool'>): False 1 2 # Run `list` command ! python src . py list container (<class 'list'>): [] filter (<class 'NoneType'>): None log (<class 'bool'>): False log_file (<class 'NoneType'>): None verbose (<class 'bool'>): False 1 ! python src . py -- log - file file . log list container (<class 'list'>): [] filter (<class 'NoneType'>): None log (<class 'bool'>): False log_file (<class 'str'>): file.log verbose (<class 'bool'>): False 1 ! python src . py -- log - file file . log list filterme container (<class 'list'>): [] filter (<class 'str'>): filterme log (<class 'bool'>): False log_file (<class 'str'>): file.log verbose (<class 'bool'>): False","title":"Usage"},{"location":"examples/4-supported-types/","text":"Supported Type in a file named src.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 from enum import Enum from typing import List , Tuple from arger import Arger from tests.utils import _reprint class Choice ( Enum ): one = '1. One' two = '2. Two' def __str__ ( self ): \"\"\"by implementing this function one can control the enum-display in help string\"\"\" return self . name arger = Arger ( prog = 'pytest' , description = \"App Description goes here\" ) container = [] @arger . add_cmd def cmd1 ( an_int : int , an_str : str , a_tuple : Tuple [ str , str , str ], # nargs: 3 -> consume 3 a_var_tuple : Tuple [ str , ... ], # nargs: + -> consume one or more an_enum = Choice . one , optional_str = '' , optional_int = 0 , optional_tpl = (), ): \"\"\"Example function with types documented in the docstring.\"\"\" _reprint ( ** locals ()) @arger . add_cmd def cmd2 ( a_list : List [ int ], # nargs='*': -> capture many args m_opt = False , y_opt = False , my = False , ): \"\"\"A script with three optional values. :param a_list: catch all positional arguments :param m_opt: the m_opt helptext :param y_opt: the y_opt helptext :param my: the my helptext \"\"\" _reprint ( ** locals ()) if __name__ == '__main__' : arger . run ()","title":"Supported Type"},{"location":"examples/4-supported-types/#supported-type","text":"in a file named src.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 from enum import Enum from typing import List , Tuple from arger import Arger from tests.utils import _reprint class Choice ( Enum ): one = '1. One' two = '2. Two' def __str__ ( self ): \"\"\"by implementing this function one can control the enum-display in help string\"\"\" return self . name arger = Arger ( prog = 'pytest' , description = \"App Description goes here\" ) container = [] @arger . add_cmd def cmd1 ( an_int : int , an_str : str , a_tuple : Tuple [ str , str , str ], # nargs: 3 -> consume 3 a_var_tuple : Tuple [ str , ... ], # nargs: + -> consume one or more an_enum = Choice . one , optional_str = '' , optional_int = 0 , optional_tpl = (), ): \"\"\"Example function with types documented in the docstring.\"\"\" _reprint ( ** locals ()) @arger . add_cmd def cmd2 ( a_list : List [ int ], # nargs='*': -> capture many args m_opt = False , y_opt = False , my = False , ): \"\"\"A script with three optional values. :param a_list: catch all positional arguments :param m_opt: the m_opt helptext :param y_opt: the y_opt helptext :param my: the my helptext \"\"\" _reprint ( ** locals ()) if __name__ == '__main__' : arger . run ()","title":"Supported Type"},{"location":"examples/4-supported-types/usage/","text":"(function() { function addWidgetsRenderer() { var requireJsScript = document.createElement('script'); requireJsScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js'; var mimeElement = document.querySelector('script[type=\"application/vnd.jupyter.widget-view+json\"]'); var jupyterWidgetsScript = document.createElement('script'); var widgetRendererSrc = 'https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js'; var widgetState; // Fallback for older version: try { widgetState = mimeElement && JSON.parse(mimeElement.innerHTML); if (widgetState && (widgetState.version_major < 2 || !widgetState.version_major)) { widgetRendererSrc = 'jupyter-js-widgets@*/dist/embed.js'; } } catch(e) {} jupyterWidgetsScript.src = widgetRendererSrc; document.body.appendChild(requireJsScript); document.body.appendChild(jupyterWidgetsScript); } document.addEventListener('DOMContentLoaded', addWidgetsRenderer); }()); 1 2 # Run empty ! python src . py 1 2 # Run help ! python src . py - h usage: pytest [-h] {cmd1,cmd2} ... App Description goes here optional arguments: -h, --help show this help message and exit commands: {cmd1,cmd2} cmd1 Example function with types documented in the docstring. cmd2 A script with three optional values. 1 2 # ran `cmd1` help ! python src . py cmd1 - h usage: pytest cmd1 [-h] [-a {one,two}] [-o OPTIONAL_STR] [-p OPTIONAL_INT] [-t [OPTIONAL_TPL [OPTIONAL_TPL ...]]] an_int an_str a_tuple a_tuple a_tuple a_var_tuple [a_var_tuple ...] Example function with types documented in the docstring. positional arguments: an_int an_str a_tuple a_var_tuple optional arguments: -h, --help show this help message and exit -a {one,two}, --an-enum {one,two} -o OPTIONAL_STR, --optional-str OPTIONAL_STR -p OPTIONAL_INT, --optional-int OPTIONAL_INT -t [OPTIONAL_TPL [OPTIONAL_TPL ...]], --optional-tpl [OPTIONAL_TPL [OPTIONAL_TPL ...]] 1 2 # ran `cmd1` with only required ! python src . py cmd1 10 str1 tp1 tp2 tp3 vtp1 a_tuple (<class 'tuple'>): ('tp1', 'tp2', 'tp3') a_var_tuple (<class 'tuple'>): ('vtp1',) an_enum (<enum 'Choice'>): one an_int (<class 'int'>): 10 an_str (<class 'str'>): str1 optional_int (<class 'int'>): 0 optional_str (<class 'str'>): optional_tpl (<class 'tuple'>): () 1 2 # ran `cmd1` with valid arguments ! python src . py cmd1 10 str1 tp1 tp2 tp3 vtp1 -- optional - tpl otp1 otp2 -- optional - tpl otp3 -- optional - str ostr -- optional - int 100 -- an - enum two a_tuple (<class 'tuple'>): ('tp1', 'tp2', 'tp3') a_var_tuple (<class 'tuple'>): ('vtp1',) an_enum (<enum 'Choice'>): two an_int (<class 'int'>): 10 an_str (<class 'str'>): str1 optional_int (<class 'int'>): 100 optional_str (<class 'str'>): ostr optional_tpl (<class 'tuple'>): ('otp1', 'otp2', 'otp3') 1 2 # ran `cmd2` help ! python src . py cmd2 - h usage: pytest cmd2 [-h] [-m] [-y] [--my] [a_list [a_list ...]] A script with three optional values. positional arguments: a_list catch all positional arguments (default: None) optional arguments: -h, --help show this help message and exit -m, --m-opt the m_opt helptext (default: False) -y, --y-opt the y_opt helptext (default: False) --my the my helptext (default: False) 1 2 # ran `cmd2` with args ! python src . py cmd2 10 100 1000 a_list (<class 'list'>): [10, 100, 1000] m_opt (<class 'bool'>): False my (<class 'bool'>): False y_opt (<class 'bool'>): False","title":"Usage"}]}